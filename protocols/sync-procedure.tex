\begin{cccProtocol}
    {$\mathsf{SyncProcedure}(\party, \sid)$}
    {sync-procedure}
    {Parties update their local clocks.}
    
    \begin{algorithmic}[1]
        \LineComment{Only called when: \party is alert, $\localTime = \protocolTime{\interval}{\interval \cdot \syncLen}$ and $\interval > 0$}

        \State{Initialize $\{ \mathtt{clockShift}_i \}_{i \in [m]}$ as an empty vector}
        \For{$i = 1$ \textbf{to} $m$}
        \State{Set \chain as $i$-th chain in \parallelChainsLocal}
        \State{$B \gets \{ \block \mathbin| (\block \in \chain) \wedge \mathsf{isStageOG}(\timestamp{\block}) = \true \}$}

        \State{$IB \gets \{\inputBlock \mathbin| (\inputBlock \in \block \in B) \wedge (\timestamp{\inputBlock} = \protocolTime{\interval}{\cdot}) \}$}

        \LineComment{Find representative beacon and compute recommendation.}

        \For{each $\inputBlock \in IB$}

        \State{Find unique $\inputBlock' \in \inputBlockBuffer$ s.t. $\inputBlock' = \inputBlock$. If inexistent, set $\inputBlock' \gets \bot$.}

        \If{$\inputBlock' \neq \bot$}
        \State{Set $\mathsf{arrivalTime}(\inputBlock) \gets \mathsf{arrivalTime}(\inputBlock')$}

        \State{$\textsf{recom}(\inputBlock, i) \gets \timestamp{\inputBlock} - \mathsf{arrivalTime}(\inputBlock)$}
        \Else
        \State{$IB \gets IB \mathbin \backslash \{ \inputBlock \}$}
        \EndIf
        \EndFor

        \State{$\mathtt{clockShift}_i \gets \med \{ \textsf{recom}(\inputBlock, i) \mathbin| \inputBlock \in IB \}$}
        \EndFor

        \LineComment{Compute interval shift using \cref{eq:sync-shift}}
        \State{$\shift_{\interval} \gets \mathsf{avg}(\mathsf{select}(\mathsf{reduce}(\mathtt{clockShift}, \eta), \eta))$}

        \LineComment{Update beacon registry}
        \For{each \inputBlock with $\mathsf{arrivalTime}(\inputBlock) = (a, \mathsf{temp})$}
        \State{$\mathsf{arrivalTime}(\inputBlock) \gets (a + \shift_{\interval}, \mathsf{final})$}
        \EndFor

        \LineComment{Update local time}
        \State{Set $\localTime \gets (\interval + 1, \round + \shift_{\interval})$}

        \State{Let $\mathcal{N}_0$ be the subsequence of \futureChains s.t. $\chain \in N_0 : \Leftrightarrow \forall \block \in \chain : \timestamp{\block} < \localTime$}

        \State{Remove each $\chain \in \mathcal{N}_0$ from \futureChains}

        \State{Call $\textsf{updateLocalChain}(\parallelChainsLocal, \parallelTreesLocal, \mathcal{N}_0)$ to update \parallelChainsLocal and \parallelTreesLocal}

        \State{Send $(\textsc{diffuse}, \sid, \parallelTreesLocal)$ to $\funcDiffuse^{\textsf{bc}}$ and proceed from here upon next activation of this procedure}
    \end{algorithmic}

    \textsc{Output:} The protocol outputs \ok to its caller (but not to \Z).
\end{cccProtocol}
